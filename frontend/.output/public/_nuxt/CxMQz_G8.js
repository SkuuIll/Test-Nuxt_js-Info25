import{n as v,t as I,i as S,a as w,b as C,c as P,d as W}from"./CRYnRe3J.js";import{e as O,r as M,J as k,x as _,ak as x}from"./BE3ND16f.js";function l(o){var s;const u=w(o);return(s=u==null?void 0:u.$el)!=null?s:u}const E=S?window:void 0;function y(...o){let s,u,n,d;if(typeof o[0]=="string"||Array.isArray(o[0])?([u,n,d]=o,s=E):[s,u,n,d]=o,!s)return v;Array.isArray(u)||(u=[u]),Array.isArray(n)||(n=[n]);const f=[],p=()=>{f.forEach(i=>i()),f.length=0},c=(i,a,e,t)=>(i.addEventListener(a,e,t),()=>i.removeEventListener(a,e,t)),m=k(()=>[l(s),w(d)],([i,a])=>{if(p(),!i)return;const e=W(a)?{...a}:a;f.push(...u.flatMap(t=>n.map(r=>c(i,t,r,e))))},{immediate:!0,flush:"post"}),h=()=>{m(),p()};return I(h),h}let g=!1;function D(o,s,u={}){const{window:n=E,ignore:d=[],capture:f=!0,detectIframe:p=!1}=u;if(!n)return v;P&&!g&&(g=!0,Array.from(n.document.body.children).forEach(e=>e.addEventListener("click",v)),n.document.documentElement.addEventListener("click",v));let c=!0;const m=e=>d.some(t=>{if(typeof t=="string")return Array.from(n.document.querySelectorAll(t)).some(r=>r===e.target||e.composedPath().includes(r));{const r=l(t);return r&&(e.target===r||e.composedPath().includes(r))}}),i=[y(n,"click",e=>{const t=l(o);if(!(!t||t===e.target||e.composedPath().includes(t))){if(e.detail===0&&(c=!m(e)),!c){c=!0;return}s(e)}},{passive:!0,capture:f}),y(n,"pointerdown",e=>{const t=l(o);c=!m(e)&&!!(t&&!e.composedPath().includes(t))},{passive:!0}),p&&y(n,"blur",e=>{setTimeout(()=>{var t;const r=l(o);((t=n.document.activeElement)==null?void 0:t.tagName)==="IFRAME"&&!(r!=null&&r.contains(n.document.activeElement))&&s(e)},0)})].filter(Boolean);return()=>i.forEach(e=>e())}function B(){const o=M(!1),s=x();return s&&_(()=>{o.value=!0},s),o}function N(o){const s=B();return O(()=>(s.value,!!o()))}function F(o,s,u={}){const{root:n,rootMargin:d="0px",threshold:f=.1,window:p=E,immediate:c=!0}=u,m=N(()=>p&&"IntersectionObserver"in p),h=O(()=>{const r=w(o);return(Array.isArray(r)?r:[r]).map(l).filter(C)});let i=v;const a=M(c),e=m.value?k(()=>[h.value,l(n),a.value],([r,L])=>{if(i(),!a.value||!r.length)return;const A=new IntersectionObserver(s,{root:l(L),rootMargin:d,threshold:f});r.forEach(b=>b&&A.observe(b)),i=()=>{A.disconnect(),i=v}},{immediate:c,flush:"post"}):v,t=()=>{i(),e(),a.value=!1};return I(t),{isSupported:m,isActive:a,pause(){i(),a.value=!1},resume(){a.value=!0},stop:t}}export{D as o,F as u};
